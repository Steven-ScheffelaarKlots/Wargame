"use client";

import { useState, useEffect } from 'react';
import { ScoreboardAPI } from '@/lib/api';
import { ScoreboardData, MissionData } from "@/lib/api/types";
import { Player, Primary, Secondary, GameState } from './types';
import Navigation from '@/components/Navigation';

// Component imports
import { LoadingIndicator } from './components/LoadingIndicator';
import { PlayerInfoPhase } from './components/PlayerInfoPhase';
import { MissionSelectPhase } from './components/MissionSelectPhase';
import { GamePhase } from './components/GamePhase';
import { SummaryPhase } from './components/SummaryPhase';

// For development fallback - will be removed in production
import { mockScoreboardData } from '@/lib/api/mockData';
import { ScoreboardData } from "@/lib/api/types";
import { Player, Primary, GameState } from './types';
import Navigation from '@/components/Navigation';

// Component imports
import { LoadingIndicator } from './components/LoadingIndicator';
import { PlayerInfoPhase } from './components/PlayerInfoPhase';
import { MissionSelectPhase } from './components/MissionSelectPhase';
import { GamePhase } from './components/GamePhase';
import { SummaryPhase } from './components/SummaryPhase';

// For development fallback - will be removed in production
import { mockScoreboardData } from '@/lib/api/mockData';

export default function Scoreboard() {
  // API data state
  const [apiData, setApiData] = useState<ScoreboardData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // Players state
  const [players, setPlayers] = useState<Player[]>([
    {
      id: '1',
      name: '',
      faction: '',
      points: [0, 0, 0, 0, 0],
      primaryPoints: [0, 0, 0, 0, 0],
      secondaryPoints: [0, 0, 0, 0, 0],
      totalPoints: 0,
      secondaries: [],
      primary: null,
      secondaryDeck: [],
      discardPile: []
    },
    {
      id: '2',
      name: '',
      faction: '',
      points: [0, 0, 0, 0, 0],
      primaryPoints: [0, 0, 0, 0, 0],
      secondaryPoints: [0, 0, 0, 0, 0],
      totalPoints: 0,
      secondaries: [],
      primary: null,
      secondaryDeck: [],
      discardPile: []
    }
  ]);

  // Game state
  const [gameState, setGameState] = useState<GameState>({
    currentTurn: 1,
    totalTurns: 5,
    mission: null,
    missionName: null,
    terrainLayout: null,
    gamePhase: 'player-info',
    firstPlayerIndex: null,
    deploysFirstIndex: null
  });
  
  // Fetch data from API
  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true);
      try {
        const response = await ScoreboardAPI.getScoreboardData();
        
        if (response.success) {
          setApiData(response.data);
        } else {
          console.error("API error:", response.error);
          setError(response.error || "Failed to fetch data");
          // Fallback to mock data in development
          setApiData(mockScoreboardData);
        }
      } catch (err) {
        console.error("Failed to fetch data:", err);
        setError("An unexpected error occurred");
        // Fallback to mock data in development
        setApiData(mockScoreboardData);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchData();
  }, []);

  // Helper function to get superfaction for a faction name
  const getSuperfactionForFaction = (factionName: string): string | null => {
    if (!apiData) return null;
    
    const faction = apiData.factions.find(f => f.name === factionName);
    return faction ? faction.superfaction : null;
  };
  
  // Get faction color class based on superfaction
  const getFactionColorClass = (factionName: string): string => {
    if (!apiData) return '';
    
    const superfaction = getSuperfactionForFaction(factionName);
    if (!superfaction) return '';
    
    switch (superfaction) {
      case 'imperium':
        return 'text-blue-600 dark:text-blue-400';
      case 'chaos':
        return 'text-red-600 dark:text-red-400';
      case 'xenos':
        return 'text-green-600 dark:text-green-400';
      default:
        return '';
    }
  };

  // Update player information
  const updatePlayerInfo = (playerId: string, field: 'name' | 'faction', value: string) => {
    setPlayers(players.map(player => 
      player.id === playerId ? { ...player, [field]: value } : player
    ));
  };

  // Move to mission selection phase
  const goToMissionSelect = () => {
    if (players.every(p => p.name && p.faction)) {
      setGameState({ ...gameState, gamePhase: 'mission-select' });
    }
  };

  // Select a mission - Called from the UI when a mission is selected
  const selectMission = (missionId: string, missionName: string, terrainLayout: string) => {
    setGameState({ 
      ...gameState,
      mission: missionId,
      missionName: missionName,
      terrainLayout: terrainLayout
    });
  };

  // Start the game
  const startGame = (firstPlayerIndex: number, deploysFirstIndex: number) => {
    if (!apiData) return;
    
    // Randomly select a primary objective
    const randomPrimaryIndex = Math.floor(Math.random() * apiData.primaryObjectives.length);
    const selectedPrimary = apiData.primaryObjectives[randomPrimaryIndex];

    // Update players with primary objectives and their own secondary decks
    const updatedPlayers = players.map(player => {
      // Create a shuffled deck of all secondaries for this player
      const shuffledDeck = [...apiData.secondaries].sort(() => 0.5 - Math.random()).map(sec => ({
        ...sec,
        active: true,
        score: 0,
        completions: 0,
        isDiscarded: false,
        isCompleted: false,
        isInactive: false
      }));
      
      // Create primary objective for player
      const primary: Primary = {
        id: selectedPrimary.id,
        name: selectedPrimary.name,
        description: selectedPrimary.description,
        pointsPerTurn: [...selectedPrimary.pointsPerTurn],
        score: [0, 0, 0, 0, 0]
      };

      return {
        ...player,
        primaryPoints: [0, 0, 0, 0, 0],
        secondaryPoints: [0, 0, 0, 0, 0],
        secondaries: [], // Start with no secondaries
        primary,
        secondaryDeck: shuffledDeck, // Each player gets their own deck
        discardPile: []  // Each player gets their own discard pile
      };
    });

    setPlayers(updatedPlayers);
    setGameState({ 
      ...gameState, 
      gamePhase: 'game', 
      firstPlayerIndex,
      deploysFirstIndex
    });
  };

  // Update primary objective points for a specific turn
  const updatePrimaryPoints = (playerId: string, turnIndex: number, points: number) => {
    setPlayers(players.map(player => {
      if (player.id === playerId && player.primary) {
        // Update primary points for the turn
        const updatedPrimaryPoints = [...player.primaryPoints];
        updatedPrimaryPoints[turnIndex] = Math.max(0, points);
        
        // Update primary score for the turn
        const updatedPrimaryScore = [...player.primary.score];
        updatedPrimaryScore[turnIndex] = Math.max(0, points);
        
        // Calculate total points
        const totalPrimaryPoints = updatedPrimaryPoints.reduce((sum, p) => sum + p, 0);
        const totalSecondaryPoints = player.secondaryPoints.reduce((sum, p) => sum + p, 0);
        
        // Calculate combined points per turn
        const updatedPoints = player.primaryPoints.map((p, i) => 
          player.primaryPoints[i] + player.secondaryPoints[i]
        );
        
        return { 
          ...player, 
          primaryPoints: updatedPrimaryPoints,
          points: updatedPoints,
          totalPoints: totalPrimaryPoints + totalSecondaryPoints,
          primary: { ...player.primary, score: updatedPrimaryScore }
        };
      }
      return player;
    }));
  };

  // Draw a secondary from the player's deck
  const drawSecondary = (playerId: string) => {
    // Find the player
    const player = players.find(p => p.id === playerId);
    if (!player) return;
    
    // Check if player's deck has cards
    if (player.secondaryDeck.length === 0) {
      alert(`No more secondaries in ${player.name}'s deck!`);
      return;
    }
    
    // Get a secondary from the top of the player's deck
    const [drawnSecondary, ...remainingDeck] = player.secondaryDeck;
    
    // Record the turn in which this secondary was drawn and initialize status properties
    const secondaryWithTurn = {
      ...drawnSecondary,
      drawnAtTurn: gameState.currentTurn,
      isDiscarded: false,
      isCompleted: false,
      isInactive: false
    };
    
    // Add the secondary to the player's hand and update their deck
    setPlayers(players.map(p => {
      if (p.id === playerId) {
        return {
          ...p,
          secondaries: [...p.secondaries, secondaryWithTurn],
          secondaryDeck: remainingDeck
        };
      }
      return p;
    }));
  };
  
  // Shuffle a secondary back into the player's deck
  const shuffleBackSecondary = (playerId: string, secondaryId: string) => {
    // Find the player and the secondary
    const player = players.find(p => p.id === playerId);
    if (!player) return;
    
    const secondary = player.secondaries.find(s => s.id === secondaryId);
    if (!secondary) return;
    
    // Track that this secondary was returned to the deck (keep the drawnAtTurn for history)
    const secondaryForDeck = {...secondary};
    
    // Add the secondary back to the player's deck and shuffle
    const updatedDeck = [...player.secondaryDeck, secondaryForDeck]
      .sort(() => 0.5 - Math.random());
    
    // Remove the secondary from the player's hand and update their deck
    setPlayers(players.map(p => {
      if (p.id === playerId) {
        return {
          ...p,
          secondaries: p.secondaries.filter(s => s.id !== secondaryId),
          secondaryDeck: updatedDeck
        };
      }
      return p;
    }));
    
    // Recalculate points
    recalculatePlayerPoints(playerId);
  };
  
  // Discard a secondary
  const discardSecondary = (playerId: string, secondaryId: string) => {
    // Find the player and the secondary
    const player = players.find(p => p.id === playerId);
    if (!player) return;
    
    // Mark the secondary as discarded instead of removing it
    setPlayers(players.map(p => {
      if (p.id === playerId) {
        return {
          ...p,
          secondaries: p.secondaries.map(sec => 
            sec.id === secondaryId 
              ? { ...sec, isDiscarded: true } 
              : sec
          )
        };
      }
      return p;
    }));
    
    // Recalculate points
    recalculatePlayerPoints(playerId);
  };
  
  // Helper to recalculate a player's points after secondary changes
  const recalculatePlayerPoints = (playerId: string) => {
    setPlayers(players.map(player => {
      if (player.id === playerId) {
        // Get the current turn index
        const turnIndex = gameState.currentTurn - 1;
        
        // Calculate total secondary points - only count non-discarded secondaries
        const totalSecondaryPoints = player.secondaries
          .filter(sec => !sec.isDiscarded)
          .reduce((sum, sec) => sum + sec.score, 0);
        
        // Update secondary points for the current turn
        const updatedSecondaryPoints = [...player.secondaryPoints];
        updatedSecondaryPoints[turnIndex] = totalSecondaryPoints;
        
        // Calculate combined points per turn
        const updatedPoints = updatedSecondaryPoints.map((sp, i) => 
          (player.primaryPoints[i] || 0) + sp
        );
        
        // Calculate total points
        const totalPoints = player.primaryPoints.reduce((sum, p) => sum + p, 0) + totalSecondaryPoints;
        
        return { 
          ...player, 
          secondaryPoints: updatedSecondaryPoints,
          points: updatedPoints,
          totalPoints
        };
      }
      return player;
    }));
  };
  
  // Update secondary objective points
  const updateSecondary = (playerId: string, secondaryId: string, action: 'score' | 'discard') => {
    setPlayers(players.map(player => {
      if (player.id === playerId) {
        // Get the current turn index
        const turnIndex = gameState.currentTurn - 1;
        
        if (action === 'score') {
          // Update the secondary
          const updatedSecondaries = player.secondaries.map(sec => {
            if (sec.id === secondaryId) {
              // Don't allow scoring of discarded, inactive, or completed secondaries
              if (sec.isDiscarded || sec.isInactive || sec.isCompleted) return sec;
              
              // Increment completions and score based on pointsPerCompletion
              const newCompletions = sec.maxCompletions 
                ? Math.min(sec.completions + 1, sec.maxCompletions)
                : sec.completions + 1;
              
              // Check if the secondary is fully completed
              const isCompleted = sec.maxCompletions !== undefined && newCompletions >= sec.maxCompletions;
              
              return { 
                ...sec, 
                score: sec.score + sec.pointsPerCompletion,
                completions: newCompletions,
                isCompleted: isCompleted
              };
            }
            return sec;
          });
          
          // Calculate total secondary points from active (non-discarded) secondaries
          const totalSecondaryPoints = updatedSecondaries
            .filter(sec => !sec.isDiscarded)
            .reduce((sum, sec) => sum + sec.score, 0);
          
          // Update secondary points for the current turn
          const updatedSecondaryPoints = [...player.secondaryPoints];
          // Assign all secondary points to the current turn for simplicity
          updatedSecondaryPoints[turnIndex] = totalSecondaryPoints;
          
          // Calculate combined points per turn
          const updatedPoints = updatedSecondaryPoints.map((sp, i) => 
            (player.primaryPoints[i] || 0) + sp
          );
          
          // Calculate total points
          const totalPoints = player.primaryPoints.reduce((sum, p) => sum + p, 0) + totalSecondaryPoints;
          
          return { 
            ...player, 
            secondaries: updatedSecondaries,
            secondaryPoints: updatedSecondaryPoints,
            points: updatedPoints,
            totalPoints
          };
        } else if (action === 'discard') {
          // Use the discard function
          discardSecondary(playerId, secondaryId);
          // This player will be updated by discardSecondary, so just return as is
          return player;
        }
      }
      return player;
    }));
  };

  // Next turn
  const nextTurn = () => {
    if (gameState.currentTurn < gameState.totalTurns) {
      // Mark completed or discarded secondaries as inactive before advancing to next turn
      const updatedPlayers = players.map(player => {
        return {
          ...player,
          secondaries: player.secondaries.map(sec => {
            // If the secondary is completed or discarded, mark it as inactive
            if (sec.isCompleted || sec.isDiscarded) {
              return {
                ...sec,
                isInactive: true
              };
            }
            return sec;
          })
        };
      });
      
      // Update players with inactive secondaries
      setPlayers(updatedPlayers);
      
      // Move to next turn
      setGameState({
        ...gameState,
        currentTurn: gameState.currentTurn + 1
      });
    } else {
      // End game
      setGameState({
        ...gameState,
        gamePhase: 'summary'
      });
    }
  };
  
  // Previous turn
  const previousTurn = () => {
    if (gameState.currentTurn > 1) {
      setGameState({
        ...gameState,
        currentTurn: gameState.currentTurn - 1
      });
    }
  };

  // Reset game
  const resetGame = () => {
    setPlayers([
      {
        id: '1',
        name: '',
        faction: '',
        points: [0, 0, 0, 0, 0],
        primaryPoints: [0, 0, 0, 0, 0],
        secondaryPoints: [0, 0, 0, 0, 0],
        totalPoints: 0,
        secondaries: [],
        primary: null,
        secondaryDeck: [],
        discardPile: []
      },
      {
        id: '2',
        name: '',
        faction: '',
        points: [0, 0, 0, 0, 0],
        primaryPoints: [0, 0, 0, 0, 0],
        secondaryPoints: [0, 0, 0, 0, 0],
        totalPoints: 0,
        secondaries: [],
        primary: null,
        secondaryDeck: [],
        discardPile: []
      }
    ]);
    
    setGameState({
      currentTurn: 1,
      totalTurns: 5,
      mission: null,
      missionName: null,
      terrainLayout: null,
      gamePhase: 'player-info',
      firstPlayerIndex: null,
      deploysFirstIndex: null
    });
  };

  // Player Info Phase
  const renderPlayerInfoPhase = () => {
    return (
      <PlayerInfoPhase
        players={players}
        apiData={apiData!}
        error={error}
        updatePlayerInfo={updatePlayerInfo}
        goToMissionSelect={goToMissionSelect}
      />
    );
  };

  // Mission Selection Phase
  // Randomize first player
  const randomizeFirstPlayer = () => {
    const randomIndex = Math.floor(Math.random() * 2);
    setGameState({
      ...gameState,
      firstPlayerIndex: randomIndex
    });
  };

  // Randomize who deploys first
  const randomizeDeploysFirst = () => {
    const randomIndex = Math.floor(Math.random() * 2);
    setGameState({
      ...gameState,
      deploysFirstIndex: randomIndex
    });
  };

  const renderMissionSelectPhase = () => {
    if (!apiData) return null;
    
    // Create a mission data object for the selected mission
    const selectedMission = gameState.mission 
      ? apiData.missions.find(m => m.id === gameState.mission) || null
      : null;
    
    return (
      <MissionSelectPhase
        gameState={{
          ...gameState,
          players,
          selectedMission
        }}
        apiData={apiData}
        selectMission={(missionId) => selectMission(
          missionId, 
          apiData.missions.find(m => m.id === missionId)?.name || '', 
          apiData.missions.find(m => m.id === missionId)?.terrainLayout || ''
        )}
        setFirstPlayerIndex={(index) => setGameState({...gameState, firstPlayerIndex: index})}
        setDeploysFirstIndex={(index) => setGameState({...gameState, deploysFirstIndex: index})}
        randomizeFirstPlayer={randomizeFirstPlayer}
        randomizeDeploysFirst={randomizeDeploysFirst}
        startGame={() => startGame(
          gameState.firstPlayerIndex !== null ? gameState.firstPlayerIndex : 0,
          gameState.deploysFirstIndex !== null ? gameState.deploysFirstIndex : 0
        )}
      />
    );
  };
              className="w-full mt-4 px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-md"
            >
              Back to Mission Selection
            </button>
          </div>
        )}
      </div>
    );
  };

  // Game Phase
  const renderGamePhase = () => {
    return (
      <GamePhase
        gameState={{
          ...gameState,
          players,
          mission: gameState.mission || '',
          missionName: gameState.missionName || 'Unknown Mission'
        }}
        apiData={apiData!}
        updateSecondary={updateSecondary}
        drawSecondary={drawSecondary}
        discardSecondary={discardSecondary}
        updatePrimary={updatePrimary}
        endTurn={endTurn}
        endGame={endGame}
      />
    );
    if (!apiData) return null;
    
    return (
      <div className="space-y-8">
        {/* Game info bar */}
        <div className="flex flex-col sm:flex-row sm:justify-between bg-black/[.03] dark:bg-white/[.03] p-4 rounded-lg">
          <div className="mb-3 sm:mb-0">
            <h2 className="font-bold">
              Mission: <span className="font-normal">{gameState.missionName || 'N/A'}</span>
            </h2>
            <p className="text-sm text-gray-600 dark:text-gray-400">
              Terrain: {gameState.terrainLayout || 'N/A'}
            </p>
            {gameState.firstPlayerIndex !== null && gameState.deploysFirstIndex !== null && (
              <div className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                <p>
                  <span className="font-medium">{players[gameState.deploysFirstIndex].name}</span> deployed first
                </p>
                <p>
                  <span className="font-medium">{players[gameState.firstPlayerIndex].name}</span> goes first
                </p>
              </div>
            )}
          </div>
          
          <div className="flex items-center">
            <button
              onClick={previousTurn}
              disabled={gameState.currentTurn === 1}
              className={`w-8 h-8 flex items-center justify-center rounded-md ${
                gameState.currentTurn === 1
                  ? 'text-gray-400 cursor-not-allowed'
                  : 'hover:bg-gray-100 dark:hover:bg-gray-800'
              }`}
            >
              &#8592;
            </button>
            
            <div className="mx-2 px-4 py-1 bg-amber-100 dark:bg-amber-900/30 rounded-md">
              <span className="font-bold">Turn {gameState.currentTurn}</span>
              <span className="text-xs text-gray-600 dark:text-gray-400 ml-1">/ {gameState.totalTurns}</span>
            </div>
            
            <button
              onClick={nextTurn}
              disabled={gameState.currentTurn === gameState.totalTurns}
              className={`w-8 h-8 flex items-center justify-center rounded-md ${
                gameState.currentTurn === gameState.totalTurns
                  ? 'text-gray-400 cursor-not-allowed'
                  : 'hover:bg-gray-100 dark:hover:bg-gray-800'
              }`}
            >
              &#8594;
            </button>
          </div>
          
          <div>
            <button
              onClick={() => setGameState({ ...gameState, gamePhase: 'summary' })}
              className="px-4 py-1 text-sm text-amber-700 dark:text-amber-300 hover:underline"
            >
              End Game
            </button>
          </div>
        </div>
        
        {/* Player boards */}
        <div className="grid grid-cols-1 gap-8">
          {players.map(player => (
            <div 
              key={player.id} 
              className="border dark:border-gray-700 rounded-lg p-6"
            >
              <div className="flex flex-col md:flex-row md:items-center md:justify-between mb-4">
                <div>
                  <h3 className="text-xl font-bold">{player.name}</h3>
                  <p>
                    <span className={`text-sm ${getFactionColorClass(player.faction)}`}>
                      {player.faction}
                    </span>
                    {getSuperfactionForFaction(player.faction) && 
                      <span className="text-xs ml-2 text-gray-500 dark:text-gray-400">
                        ({getSuperfactionForFaction(player.faction)})
                      </span>
                    }
                  </p>
                </div>
                <div className="mt-2 md:mt-0">
                  <p>
                    <span className="text-xl font-bold">{player.totalPoints}</span>
                    <span className="text-sm ml-1">points</span>
                  </p>
                </div>
              </div>
              
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {/* Primary objectives */}
                <div className="border dark:border-gray-700 rounded-md p-4">
                  <h4 className="font-bold mb-2">Primary Objective</h4>
                  
                  {player.primary ? (
                    <>
                      <p className="font-medium">{player.primary.name}</p>
                      <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">{player.primary.description}</p>
                      
                      <div className="grid grid-cols-5 gap-2 mb-2">
                        {[1, 2, 3, 4, 5].map(turn => (
                          <div 
                            key={turn}
                            className={`text-center p-2 ${
                              turn === gameState.currentTurn 
                                ? 'bg-amber-100 dark:bg-amber-900/30 rounded' 
                                : ''
                            }`}
                          >
                            <div className="text-xs text-gray-500 mb-1">Turn {turn}</div>
                            <div className="font-medium">{player.primary?.pointsPerTurn[turn - 1] || 0}</div>
                          </div>
                        ))}
                      </div>
                      
                      {/* Input for current turn */}
                      <div className="mt-4">
                        <label htmlFor={`primary-${player.id}`} className="block text-sm font-medium mb-1">
                          Points for Turn {gameState.currentTurn}
                        </label>
                        <input
                          id={`primary-${player.id}`}
                          type="number"
                          value={player.primaryPoints[gameState.currentTurn - 1]}
                          onChange={(e) => updatePrimaryPoints(
                            player.id, 
                            gameState.currentTurn - 1, 
                            parseInt(e.target.value) || 0
                          )}
                          className="w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-md dark:bg-gray-800"
                          min="0"
                          max={player.primary.pointsPerTurn[gameState.currentTurn - 1]}
                        />
                      </div>
                    </>
                  ) : (
                    <p className="text-gray-500">No primary objective assigned</p>
                  )}
                </div>
                
                {/* Secondary objectives */}
                <div className="border dark:border-gray-700 rounded-md p-4">
                  <div className="flex justify-between mb-4">
                    <h4 className="font-bold">Secondary Objectives</h4>
                    
                    <div className="text-xs">
                      <span className="mr-2">{player.secondaryDeck.length} in deck</span>
                      <span>{player.discardPile.length} discarded</span>
                    </div>
                  </div>
                  
                  <button
                    onClick={() => drawSecondary(player.id)}
                    className="w-full mb-4 px-4 py-2 bg-amber-600 hover:bg-amber-700 text-white rounded-md disabled:bg-gray-300 disabled:text-gray-500 disabled:cursor-not-allowed"
                    disabled={player.secondaryDeck.length === 0}
                  >
                    Draw Secondary
                  </button>
                  
                  <div className="space-y-4">
                    {player.secondaries.map(secondary => (
                      <div 
                        key={secondary.id}
                        className={`border rounded-md p-3 ${
                          secondary.isInactive 
                            ? 'border-gray-300 dark:border-gray-600 bg-gray-100 dark:bg-gray-800/50 opacity-75' 
                            : secondary.isDiscarded 
                              ? 'border-red-200 dark:border-red-900 bg-red-50 dark:bg-red-900/10' 
                              : secondary.isCompleted
                                ? 'border-green-200 dark:border-green-900 bg-green-50 dark:bg-green-900/10'
                                : 'border-gray-200 dark:border-gray-700'
                        }`}
                      >
                        <div className="flex justify-between">
                          <h5 className="font-medium">{secondary.name}</h5>
                          <span className="text-amber-600 font-mono">{secondary.score} pts</span>
                        </div>
                        
                        {secondary.category && (
                          <div className="text-xs text-gray-500 mb-1">
                            Category: {secondary.category}
                          </div>
                        )}
                        
                        <p className="text-sm text-gray-600 dark:text-gray-400 mb-2">
                          {secondary.shortDescription}
                        </p>
                        
                        <details className="text-xs mb-3">
                          <summary className="cursor-pointer text-blue-600">Full rules</summary>
                          <p className="mt-2 p-2 bg-gray-50 dark:bg-gray-800 rounded">
                            {secondary.description}
                          </p>
                        </details>
                        
                        {/* Progress bar for completion if max exists */}
                        {secondary.maxCompletions && (
                          <div className="mb-3">
                            <div className="flex justify-between text-xs mb-1">
                              <span>Completions: {secondary.completions}/{secondary.maxCompletions}</span>
                              <span>{secondary.pointsPerCompletion} pts each</span>
                            </div>
                            <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-1.5">
                              <div 
                                className="bg-amber-600 h-1.5 rounded-full" 
                                style={{ width: `${(secondary.completions / secondary.maxCompletions) * 100}%` }}
                              ></div>
                            </div>
                          </div>
                        )}
                        
                        <div className="flex gap-2">
                          {/* Status indicator */}
                          {secondary.isInactive && (
                            <span className="text-xs px-2 py-1 bg-gray-300 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded flex-grow text-center">
                              Inactive (Turn {secondary.drawnAtTurn})
                            </span>
                          )}
                          {!secondary.isInactive && secondary.isDiscarded && (
                            <span className="text-xs px-2 py-1 bg-red-200 dark:bg-red-900/30 text-red-700 dark:text-red-300 rounded flex-grow text-center">
                              Discarded
                            </span>
                          )}
                          {!secondary.isInactive && secondary.isCompleted && !secondary.isDiscarded && (
                            <span className="text-xs px-2 py-1 bg-green-200 dark:bg-green-900/30 text-green-700 dark:text-green-300 rounded flex-grow text-center">
                              Completed
                            </span>
                          )}
                          
                          {!secondary.isInactive && (
                            <>
                              <button
                                onClick={() => updateSecondary(player.id, secondary.id, 'score')}
                                className="text-xs px-2 py-1 bg-green-500 hover:bg-green-600 text-white rounded disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled={
                                  (secondary.maxCompletions !== undefined && secondary.completions >= secondary.maxCompletions) ||
                                  secondary.isDiscarded || 
                                  secondary.isCompleted
                                }
                              >
                                Score +{secondary.pointsPerCompletion}
                              </button>
                              <button
                                onClick={() => shuffleBackSecondary(player.id, secondary.id)}
                                className="text-xs px-2 py-1 bg-yellow-500 hover:bg-yellow-600 text-white rounded disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled={secondary.isDiscarded || secondary.isCompleted}
                              >
                                Shuffle Back
                              </button>
                              <button
                                onClick={() => updateSecondary(player.id, secondary.id, 'discard')}
                                className="text-xs px-2 py-1 bg-red-500 hover:bg-red-600 text-white rounded disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled={secondary.isDiscarded}
                              >
                                Discard
                              </button>
                            </>
                          )}
                        </div>
                      </div>
                    ))}
                    
                    {player.secondaries.length === 0 && (
                      <p className="text-sm italic text-gray-500">No active secondaries - Draw a secondary to start</p>
                    )}
                  </div>
                  
                  {/* Discarded secondaries */}
                  {player.discardPile.length > 0 && (
                    <div className="mt-6 space-y-3">
                      <h5 className="font-medium text-sm border-b pb-1 dark:border-gray-700">Discarded Secondaries</h5>
                      <div className="space-y-2">
                        {player.discardPile.map((secondary) => (
                          <div 
                            key={secondary.id}
                            className="border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800/50 rounded-md p-2"
                          >
                            <div className="flex justify-between">
                              <h6 className="font-medium text-sm">{secondary.name}</h6>
                              <span className="text-amber-600 text-sm font-mono">{secondary.score} pts</span>
                            </div>
                            {secondary.category && (
                              <div className="text-xs text-gray-500">Category: {secondary.category}</div>
                            )}
                            <div className="text-xs text-gray-500">Drawn on turn: {secondary.drawnAtTurn || '?'}</div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
                
                {/* Points summary */}
                <div className="pt-2 border-t border-gray-200 dark:border-gray-700">
                  <h4 className="font-medium mb-2">Points Summary</h4>
                  
                  <div className="grid grid-cols-6 gap-1 text-center text-sm">
                    <div className="p-1"></div>
                    {[1, 2, 3, 4, 5].map(turn => (
                      <div key={turn} className="p-1">
                        <div className="text-xs text-gray-500">Turn {turn}</div>
                      </div>
                    ))}
                  </div>
                  
                  <div className="grid grid-cols-6 gap-1 text-center text-sm border-b border-gray-200 dark:border-gray-700 pb-2 mb-2">
                    <div className="p-1 text-left font-medium text-xs">Primary</div>
                    {player.primaryPoints.map((points, i) => (
                      <button 
                        key={i}
                        onClick={() => setGameState({ ...gameState, currentTurn: i+1 })}
                        className={`p-1 rounded cursor-pointer transition-colors ${
                          i === gameState.currentTurn - 1 
                            ? 'bg-amber-100 dark:bg-amber-900/30' 
                            : i < gameState.currentTurn - 1
                              ? 'bg-slate-100 dark:bg-slate-800/30 hover:bg-amber-50 dark:hover:bg-amber-900/10' 
                              : 'text-gray-400 dark:text-gray-600 hover:bg-gray-100 dark:hover:bg-gray-800/30'
                        }`}
                      >
                        <div>{points}</div>
                      </button>
                    ))}
                  </div>
                  
                  <div className="grid grid-cols-6 gap-1 text-center text-sm border-b border-gray-200 dark:border-gray-700 pb-2 mb-2">
                    <div className="p-1 text-left font-medium text-xs">Secondary</div>
                    {player.secondaryPoints.map((points, i) => (
                      <button 
                        key={i}
                        onClick={() => setGameState({ ...gameState, currentTurn: i+1 })}
                        className={`p-1 rounded cursor-pointer transition-colors ${
                          i === gameState.currentTurn - 1 
                            ? 'bg-amber-100 dark:bg-amber-900/30' 
                            : i < gameState.currentTurn - 1
                              ? 'bg-slate-100 dark:bg-slate-800/30 hover:bg-amber-50 dark:hover:bg-amber-900/10' 
                              : 'text-gray-400 dark:text-gray-600 hover:bg-gray-100 dark:hover:bg-gray-800/30'
                        }`}
                      >
                        <div>{points}</div>
                      </button>
                    ))}
                  </div>
                  
                  <div className="grid grid-cols-6 gap-1 text-center text-sm font-semibold">
                    <div className="p-1 text-left">Total</div>
                    {player.points.map((points, i) => (
                      <button 
                        key={i}
                        onClick={() => setGameState({ ...gameState, currentTurn: i+1 })}
                        className={`p-1 rounded cursor-pointer transition-colors ${
                          i === gameState.currentTurn - 1 
                            ? 'bg-amber-100 dark:bg-amber-900/30 font-bold' 
                            : i < gameState.currentTurn - 1
                              ? 'bg-slate-100 dark:bg-slate-800/30 hover:bg-amber-50 dark:hover:bg-amber-900/10' 
                              : 'text-gray-400 dark:text-gray-600 hover:bg-gray-100 dark:hover:bg-gray-800/30'
                        }`}
                      >
                        <div>{points}</div>
                      </button>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  };

  // Render the summary phase
  const renderSummaryPhase = () => (
    <SummaryPhase 
      gameState={{
        ...gameState,
        players,
        missionName: gameState.missionName || 'Unknown Mission'
      }}
      resetGame={resetGame}
    />
  );

  return (
    <div className="min-h-screen p-4 pb-20 sm:p-6">
      <Navigation />
      
      <div className="py-6">
        <h1 className="text-3xl font-bold mb-3">Warhammer 40k Scoreboard</h1>
        <p className="text-gray-600 dark:text-gray-400 max-w-2xl mb-8">
          Track your Warhammer 40k 10th Edition battles with this scoreboard tool.
        </p>
      </div>

      {isLoading && <LoadingIndicator />}

      {!isLoading && (
        <>
          {/* Render different content based on game phase */}
          {gameState.gamePhase === 'player-info' && renderPlayerInfoPhase()}
          {gameState.gamePhase === 'mission-select' && renderMissionSelectPhase()}
          {gameState.gamePhase === 'game' && renderGamePhase()}
          {gameState.gamePhase === 'summary' && renderSummaryPhase()}
        </>
      )}
    </div>
  );
}
